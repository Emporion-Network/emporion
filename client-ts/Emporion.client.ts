/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint128, AssetInfoBaseForString, AssetListBaseForString, Duration, InstantiateMsg, Distribution, AssetBaseForString, ExecuteMsg, Binary, CreateOrderExecuteMsg, ReviewUserExecuteMsg, ReviewProductExecuteMsg, CreateProductExecuteMessage, Cw20ReceiveMsg, QueryMsg, MigrateMsg, AssetInfoBaseForAddr, Addr, AssetListBaseForAddr, Bank, AssetBaseForAddr, InfoResponse, ContractVersion, Expiration, Timestamp, Uint64, OrderStatus, Order, TupleOfArrayOfOrderAndNullableUint64, ContractParams, TupleOfArrayOfProductAndNullableUint64, Product, TupleOfArrayOfReviewAndNullableUint64, ReviewOf, Review, TotalPowerAtHeightResponse, User, VotingPowerAtHeightResponse } from "./Emporion.types";
export interface EmporionReadOnlyInterface {
  contractAddress: string;
  info: () => Promise<InfoResponse>;
  totalPowerAtHeight: ({
    height
  }: {
    height?: number;
  }) => Promise<TotalPowerAtHeightResponse>;
  params: () => Promise<ContractParams>;
  bank: () => Promise<Bank>;
  votingPowerAtHeight: ({
    address,
    height
  }: {
    address: string;
    height?: number;
  }) => Promise<VotingPowerAtHeightResponse>;
  userStats: ({
    addr
  }: {
    addr: string;
  }) => Promise<User>;
  ordersFromBuyer: ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }) => Promise<TupleOfArrayOfOrderAndNullableUint64>;
  order: ({
    orderId
  }: {
    orderId: number;
  }) => Promise<Order>;
  ordersForSeller: ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }) => Promise<TupleOfArrayOfOrderAndNullableUint64>;
  reviewsOfProduct: ({
    productId,
    startFrom
  }: {
    productId: number;
    startFrom?: number;
  }) => Promise<TupleOfArrayOfReviewAndNullableUint64>;
  reviewsOfReviewed: ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }) => Promise<TupleOfArrayOfReviewAndNullableUint64>;
  reviewsFromReviewer: ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }) => Promise<TupleOfArrayOfReviewAndNullableUint64>;
  productsOfSeller: ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }) => Promise<TupleOfArrayOfProductAndNullableUint64>;
  productAll: ({
    startFrom
  }: {
    startFrom?: number;
  }) => Promise<TupleOfArrayOfProductAndNullableUint64>;
  productById: ({
    productId
  }: {
    productId: number;
  }) => Promise<Product>;
}
export class EmporionQueryClient implements EmporionReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.info = this.info.bind(this);
    this.totalPowerAtHeight = this.totalPowerAtHeight.bind(this);
    this.params = this.params.bind(this);
    this.bank = this.bank.bind(this);
    this.votingPowerAtHeight = this.votingPowerAtHeight.bind(this);
    this.userStats = this.userStats.bind(this);
    this.ordersFromBuyer = this.ordersFromBuyer.bind(this);
    this.order = this.order.bind(this);
    this.ordersForSeller = this.ordersForSeller.bind(this);
    this.reviewsOfProduct = this.reviewsOfProduct.bind(this);
    this.reviewsOfReviewed = this.reviewsOfReviewed.bind(this);
    this.reviewsFromReviewer = this.reviewsFromReviewer.bind(this);
    this.productsOfSeller = this.productsOfSeller.bind(this);
    this.productAll = this.productAll.bind(this);
    this.productById = this.productById.bind(this);
  }
  info = async (): Promise<InfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      info: {}
    });
  };
  totalPowerAtHeight = async ({
    height
  }: {
    height?: number;
  }): Promise<TotalPowerAtHeightResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_power_at_height: {
        height
      }
    });
  };
  params = async (): Promise<ContractParams> => {
    return this.client.queryContractSmart(this.contractAddress, {
      params: {}
    });
  };
  bank = async (): Promise<Bank> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bank: {}
    });
  };
  votingPowerAtHeight = async ({
    address,
    height
  }: {
    address: string;
    height?: number;
  }): Promise<VotingPowerAtHeightResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      voting_power_at_height: {
        address,
        height
      }
    });
  };
  userStats = async ({
    addr
  }: {
    addr: string;
  }): Promise<User> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_stats: {
        addr
      }
    });
  };
  ordersFromBuyer = async ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }): Promise<TupleOfArrayOfOrderAndNullableUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      orders_from_buyer: {
        addr,
        start_from: startFrom
      }
    });
  };
  order = async ({
    orderId
  }: {
    orderId: number;
  }): Promise<Order> => {
    return this.client.queryContractSmart(this.contractAddress, {
      order: {
        order_id: orderId
      }
    });
  };
  ordersForSeller = async ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }): Promise<TupleOfArrayOfOrderAndNullableUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      orders_for_seller: {
        addr,
        start_from: startFrom
      }
    });
  };
  reviewsOfProduct = async ({
    productId,
    startFrom
  }: {
    productId: number;
    startFrom?: number;
  }): Promise<TupleOfArrayOfReviewAndNullableUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reviews_of_product: {
        product_id: productId,
        start_from: startFrom
      }
    });
  };
  reviewsOfReviewed = async ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }): Promise<TupleOfArrayOfReviewAndNullableUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reviews_of_reviewed: {
        addr,
        start_from: startFrom
      }
    });
  };
  reviewsFromReviewer = async ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }): Promise<TupleOfArrayOfReviewAndNullableUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      reviews_from_reviewer: {
        addr,
        start_from: startFrom
      }
    });
  };
  productsOfSeller = async ({
    addr,
    startFrom
  }: {
    addr: string;
    startFrom?: number;
  }): Promise<TupleOfArrayOfProductAndNullableUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      products_of_seller: {
        addr,
        start_from: startFrom
      }
    });
  };
  productAll = async ({
    startFrom
  }: {
    startFrom?: number;
  }): Promise<TupleOfArrayOfProductAndNullableUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      product_all: {
        start_from: startFrom
      }
    });
  };
  productById = async ({
    productId
  }: {
    productId: number;
  }): Promise<Product> => {
    return this.client.queryContractSmart(this.contractAddress, {
      product_by_id: {
        product_id: productId
      }
    });
  };
}
export interface EmporionInterface extends EmporionReadOnlyInterface {
  contractAddress: string;
  sender: string;
  blacklist: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unblacklist: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  invest: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  divest: ({
    toDivest
  }: {
    toDivest: AssetListBaseForString;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createOrder: ({
    buyerRiskShare,
    cart,
    ready,
    seller
  }: {
    buyerRiskShare: number[][];
    cart: number[][];
    ready: boolean;
    seller: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptOrder: ({
    orderId
  }: {
    orderId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  finalizeOrder: ({
    orderId
  }: {
    orderId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addProductsToOrder: ({
    cart,
    orderId
  }: {
    cart: number[][];
    orderId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  rejectOrder: ({
    orderId
  }: {
    orderId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  fulfillOrder: ({
    orderId
  }: {
    orderId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  disputeOrder: ({
    orderId
  }: {
    orderId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  reviewUser: ({
    message,
    orderId,
    rating
  }: {
    message: string;
    orderId: number;
    rating: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  reviewProduct: ({
    message,
    orderId,
    productId,
    rating
  }: {
    message: string;
    orderId: number;
    productId: number;
    rating: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createProduct: ({
    deliveryTime,
    isListed,
    meta,
    price
  }: {
    deliveryTime: Duration;
    isListed: boolean;
    meta: string;
    price: AssetListBaseForString;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  listProduct: ({
    productId
  }: {
    productId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unListProduct: ({
    productId
  }: {
    productId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  distributeRewards: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawToDev: ({
    amount,
    to
  }: {
    amount: AssetListBaseForString;
    to: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class EmporionClient extends EmporionQueryClient implements EmporionInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.blacklist = this.blacklist.bind(this);
    this.unblacklist = this.unblacklist.bind(this);
    this.invest = this.invest.bind(this);
    this.divest = this.divest.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.createOrder = this.createOrder.bind(this);
    this.acceptOrder = this.acceptOrder.bind(this);
    this.finalizeOrder = this.finalizeOrder.bind(this);
    this.addProductsToOrder = this.addProductsToOrder.bind(this);
    this.rejectOrder = this.rejectOrder.bind(this);
    this.fulfillOrder = this.fulfillOrder.bind(this);
    this.disputeOrder = this.disputeOrder.bind(this);
    this.reviewUser = this.reviewUser.bind(this);
    this.reviewProduct = this.reviewProduct.bind(this);
    this.createProduct = this.createProduct.bind(this);
    this.listProduct = this.listProduct.bind(this);
    this.unListProduct = this.unListProduct.bind(this);
    this.receive = this.receive.bind(this);
    this.distributeRewards = this.distributeRewards.bind(this);
    this.withdrawToDev = this.withdrawToDev.bind(this);
  }
  blacklist = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      blacklist: {}
    }, fee, memo, _funds);
  };
  unblacklist = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unblacklist: {}
    }, fee, memo, _funds);
  };
  invest = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      invest: {}
    }, fee, memo, _funds);
  };
  divest = async ({
    toDivest
  }: {
    toDivest: AssetListBaseForString;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      divest: {
        to_divest: toDivest
      }
    }, fee, memo, _funds);
  };
  withdraw = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {}
    }, fee, memo, _funds);
  };
  createOrder = async ({
    buyerRiskShare,
    cart,
    ready,
    seller
  }: {
    buyerRiskShare: number[][];
    cart: number[][];
    ready: boolean;
    seller: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_order: {
        buyer_risk_share: buyerRiskShare,
        cart,
        ready,
        seller
      }
    }, fee, memo, _funds);
  };
  acceptOrder = async ({
    orderId
  }: {
    orderId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_order: {
        order_id: orderId
      }
    }, fee, memo, _funds);
  };
  finalizeOrder = async ({
    orderId
  }: {
    orderId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      finalize_order: {
        order_id: orderId
      }
    }, fee, memo, _funds);
  };
  addProductsToOrder = async ({
    cart,
    orderId
  }: {
    cart: number[][];
    orderId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_products_to_order: {
        cart,
        order_id: orderId
      }
    }, fee, memo, _funds);
  };
  rejectOrder = async ({
    orderId
  }: {
    orderId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reject_order: {
        order_id: orderId
      }
    }, fee, memo, _funds);
  };
  fulfillOrder = async ({
    orderId
  }: {
    orderId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      fulfill_order: {
        order_id: orderId
      }
    }, fee, memo, _funds);
  };
  disputeOrder = async ({
    orderId
  }: {
    orderId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      dispute_order: {
        order_id: orderId
      }
    }, fee, memo, _funds);
  };
  reviewUser = async ({
    message,
    orderId,
    rating
  }: {
    message: string;
    orderId: number;
    rating: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      review_user: {
        message,
        order_id: orderId,
        rating
      }
    }, fee, memo, _funds);
  };
  reviewProduct = async ({
    message,
    orderId,
    productId,
    rating
  }: {
    message: string;
    orderId: number;
    productId: number;
    rating: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      review_product: {
        message,
        order_id: orderId,
        product_id: productId,
        rating
      }
    }, fee, memo, _funds);
  };
  createProduct = async ({
    deliveryTime,
    isListed,
    meta,
    price
  }: {
    deliveryTime: Duration;
    isListed: boolean;
    meta: string;
    price: AssetListBaseForString;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_product: {
        delivery_time: deliveryTime,
        is_listed: isListed,
        meta,
        price
      }
    }, fee, memo, _funds);
  };
  listProduct = async ({
    productId
  }: {
    productId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      list_product: {
        product_id: productId
      }
    }, fee, memo, _funds);
  };
  unListProduct = async ({
    productId
  }: {
    productId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      un_list_product: {
        product_id: productId
      }
    }, fee, memo, _funds);
  };
  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee, memo, _funds);
  };
  distributeRewards = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      distribute_rewards: {}
    }, fee, memo, _funds);
  };
  withdrawToDev = async ({
    amount,
    to
  }: {
    amount: AssetListBaseForString;
    to: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_to_dev: {
        amount,
        to
      }
    }, fee, memo, _funds);
  };
}